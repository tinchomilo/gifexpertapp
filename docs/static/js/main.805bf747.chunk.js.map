{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","placeholder","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAIaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cACzB,EAAmCC,mBAAS,IAA5C,mBAAMC,EAAN,KAAkBC,EAAlB,KAeA,OACI,sBAAMC,SAVW,SAACC,GAClBA,EAAEC,iBACCJ,EAAWK,OAAOC,OAAS,IAC1BR,GAAc,SAACS,GAAD,OAAYP,GAAZ,mBAA2BO,OAEzCN,EAAc,MAKlB,SACI,uBACAO,KAAM,OACNC,MAAQT,EACRU,SAlBkB,SAACP,GACvBF,EAAcE,EAAEQ,OAAOF,QAkBnBG,YAAY,gC,+BC1BXC,EAAO,uCAAG,WAAQC,GAAR,uBAAAC,EAAA,6DAEbC,EAFa,gDAEmCC,UAAYH,GAF/C,+DAIAI,MAAOF,GAJP,cAIbG,EAJa,gBAKIA,EAAKC,OALT,uBAKXC,EALW,EAKXA,KAGFC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAZvB,kBAeZM,GAfY,4CAAH,sDCEPO,EAAc,SAAC,GAAsB,IAAnBH,EAAkB,EAAlBA,MAAOV,EAAW,EAAXA,IAElC,OACI,sBAAKc,UAAU,OAAf,UACI,qBAAKC,IAAOf,EAAMgB,IAAON,IACzB,8BAAKA,EAAL,WCHCO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAEtB,ECFwB,SAAEA,GAE1B,MAA0Bf,mBAAS,CAC/BsB,KAAM,GACNa,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KAiBA,OAVAC,qBAAW,WACHxB,EAASC,GACJwB,MAAM,SAAAC,GACCH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAGtB,CAAEpB,IAENqB,EDjB0BK,CAAc1B,GAAlCa,EAAb,EAAQN,KAAaa,EAArB,EAAqBA,QAErB,OACI,qCACI,oBAAIJ,UAAU,oCAAd,SAAoDhB,IAElDoB,GAAW,0CAEb,qBAAKJ,UAAU,8CAAf,SAEYH,EAAOJ,KAAK,SAAAC,GAAG,OACX,cAAC,EAAD,eAEKA,GADEA,EAAIC,aEV1BgB,EAAe,WAExB,MAAoC1C,mBAAS,CAAC,WAA9C,mBAAO2C,EAAP,KAAmB5C,EAAnB,KAEA,OACI,gCACI,8CACA,cAAC,EAAD,CAAaA,cAAiBA,IAC9B,uBACA,6BAEQ4C,EAAWnB,KAAI,SAAAT,GAAQ,OACvB,cAAC,EAAD,CACSA,SAAYA,GADNA,Y,MCbnC6B,IAASC,OAEL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.805bf747.chunk.js","sourcesContent":["import React from 'react'\r\nimport { useState } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport const AddCategory = ({setCategories}) => {\r\n    const[inputValue, setInputValue] = useState('');\r\n\r\n    const handleInputChange = (e) => {\r\n        setInputValue(e.target.value)\r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n        e.preventDefault();\r\n        if(inputValue.trim().length > 2 ){\r\n            setCategories((cats) => [ inputValue, ...cats ]);\r\n            //              |callback de setCategories.\r\n            setInputValue('')// hace que se borre el input luego de darle enter\r\n        }\r\n    }\r\n\r\n    return (\r\n        <form onSubmit={ handleSubmit }>\r\n            <input \r\n            type= 'text' \r\n            value={ inputValue}  \r\n            onChange={ handleInputChange }\r\n            placeholder='ingresa una categoria...'/>\r\n        </form>\r\n    )\r\n}\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}","export const getGifs = async ( category ) => {\r\n    \r\n    const url = `http://api.giphy.com/v1/gifs/search?q=${ encodeURI ( category ) }&limit=10&api_key=qP8rHo4FWUfNUp43HYrDikTUgmlsmIJz`;\r\n\r\n    const resp = await fetch( url ); // Hago la peticion a la url\r\n    const { data } = await resp.json(); // obtengo como respuesta un objeto del tipo json\r\n    \r\n\r\n    const gifs = data.map(img => { // al hacer destructuring de data cunado recibo la respuesta de la api, hago un mapeo de la data, y guardo en una variable los datos que me interesan, retornando(creando) un objeto\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    })\r\n    return gifs    \r\n    }\r\n\r\n    // esta funcion no obtiene las imagenes, devuelve una promesa que resuelve la coleccion de imagenes","import React from 'react'\r\n\r\nexport const GifGridItem = ( { title, url } ) => {\r\n   \r\n    return (\r\n        <div className='card'>\r\n            <img src= { url } alt= { title }/>\r\n            <p>{ title } </p> \r\n        </div>\r\n    )\r\n}\r\n","import React from 'react'\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n// la funcion getGifs hace la peticion a la url de las imagenes. Para hacerlo utiliza promesa. la promea es una funcion normal, que tiene agregado delante del () el async. Este lo que hace es que al estar acompaÃ±ado del await, transforma la peticion como si fuera sincrona, esto quiere decir, que hasta que no obtenga la respuesta de la url no siga.\r\nexport const GifGrid = ({ category }) => {\r\n\r\n    const { data:images, loading } = useFetchGifs( category )    \r\n   \r\n    return (\r\n        <>\r\n            <h3 className='animate__animated animate__bounce'>{ category }</h3>\r\n\r\n            { loading && <p>'Loading'</p> }\r\n\r\n            <div className='card-grid animate__animated animate__zoomIn'>                               \r\n                    {\r\n                        images.map( img => (\r\n                            <GifGridItem \r\n                            key ={ img.id }                            \r\n                            { ...img }/>\r\n                        ))\r\n                    }                            \r\n            </div>\r\n        </>\r\n    )\r\n}\r\n\r\n// const apiKey = 'qP8rHo4FWUfNUp43HYrDikTUgmlsmIJz'\r\n","import { useState, useEffect } from \"react\"\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n    \r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n     // useEffect recibe una funcion, y el segundo parametro es un arreglo\r\n    // esto hace que cuando el componente se  renderize se ejecute solo 1 vez, y no haga la llamada a la api cada vez que toco el boton\r\n    useEffect( () => {          \r\n            getGifs( category ) \r\n                .then( imgs => {                   \r\n                        setState({\r\n                            data: imgs,\r\n                            loading: false\r\n                        });                                      \r\n                })\r\n            }, [ category ])\r\n            \r\n    return state; // {data: [], loading: true}\r\n}\r\n\r\n// (1) ====> .then( setImages ). como la el primer argumento de la funcion es el mismo que envia a la otra funcion se puede obviar el parametro imgs         ","import React from 'react'\r\nimport { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n\r\n\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    const [categories, setCategories] = useState(['Naruto']);\r\n    \r\n    return (\r\n        <div>\r\n            <h2>GifExpertApp</h2>\r\n            <AddCategory setCategories= { setCategories }/>\r\n            <hr />\r\n            <ol>\r\n                {\r\n                    categories.map(category => (\r\n                    <GifGrid key={ category }\r\n                             category= { category } />\r\n                        ))\r\n                }\r\n            </ol>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default GifExpertApp\r\n\r\n\r\n\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\nimport './index.css';\n\n\n\nReactDOM.render(\n  \n    <GifExpertApp />, \n  document.getElementById('root')\n);\n"],"sourceRoot":""}